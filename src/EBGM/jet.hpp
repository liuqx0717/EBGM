#pragma once

#include "kernels.h"
#include "utils.h"

#include <tuple>
#include <memory>
#include <iostream>

#include <opencv2/core.hpp>

#include <boost/archive/binary_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>

#define PI 3.14159265358979323846F

// The kernels used to calculate a jet
template <int N>
struct Kernels {
    static_assert(N > 0, "The 'N' in 'Kernels<N>' must be a positive integer.");

    cv::Mat re[N];
    cv::Mat im[N];

    // DO NOT modify kx and ky in a jet!
    // The ks used to generate Garbor kernels.
    // Different jets generated by the same set of Garbor
    // kernels will have the same ks, so I use heap to
    // reduce memory usage.
    std::shared_ptr<float[]> kx;
    std::shared_ptr<float[]> ky;
};


// The definition of a jet, functions for comparing
// and displacement estimation
template <int N>
struct Jet {
    static_assert(N > 0, "The 'N' in Jet<N> must be a positive integer.");

    // DO NOT modify kx and ky in a jet!
    // The ks used to generate Garbor kernels.
    // Different jets generated by the same set of Garbor
    // kernels will have the same ks, so I use heap to
    // reduce memory usage.
    std::shared_ptr<float[]> kx;
    std::shared_ptr<float[]> ky;

    int x;
    int y;

    // magnitudes
    float a[N];

    // phases
    float p[N];

    // compare without phase information
    float compare(const Jet<N> &jet) const
    {
        float sum_ab = 0;
        float sum_aa = 0;
        float sum_bb = 0;

        for(int i=0; i<N; i++) {
            float a1, a2;      // a and a'

            a1 = a[i];
            a2 = jet.a[i];

            sum_ab += a1*a2;
            sum_aa += a1*a1;
            sum_bb += a2*a2;
        }

        return sum_ab / sqrtf(sum_aa*sum_bb);
    }


    float compareWithPhase(const Jet<N> &jet, float dx, float dy) const
    {
        float sum_abcos = 0;
        float sum_aa = 0;
        float sum_bb = 0;

        auto kx_p = kx.get();
        auto ky_p = ky.get();
        for(int i=0; i<N; i++) {
            float a1, a2;   // a and a'
            float kx, ky;
            float p1, p2;   // phi and phi'

            a1 = a[i];
            a2 = jet.a[i];
            p1 = p[i];
            p2 = jet.p[i];
            kx = kx_p[i];
            ky = ky_p[i];
            
            sum_abcos += a1*a2 * cosf(p1 - p2 - (dx*kx + dy*ky));
            sum_aa += a1*a1;
            sum_bb += a2*a2;
        }

        return sum_abcos / sqrtf(sum_aa*sum_bb);
    }


    // DO NOT calculate the displacement of jets generated by DIFFERENT
    // sets of Garbor kernels!
    // You have to use smallest k first (will get a big d), then INCLUDE
    // larger k (that is, add new ks to previously used ones by enlarging
    // index range), ... , until all of the different sizes of k are covered.
    // Thus d will be more and more precise.
    std::tuple<float/*dx*/,float/*dy*/>
    displacement(
        const Jet<N> &jet, 
        int startIndex = 0, 
        int count = N, // Automatically set to N - startIndex if too big
        float dx0 = 0.0F, // The previous result of displacement estimation,
        float dy0 = 0.0F  // on which the refinement is based.
    ) const
    {

        assert(count != 0);
        count = (count + startIndex <= N ? count : N - startIndex);

        float Phi_x = 0;
        float Phi_y = 0;
        float Gamma_xx = 0;
        float Gamma_yy = 0;
        float Gamma_xy = 0;
        float Gamma_yx = 0;

        auto kx_p = kx.get();
        auto ky_p = ky.get();
        for(int i=0; i<count; i++){
            float a1, a2, kx, ky, phi1, phi2, deltaPhi;
            a1 = a[startIndex + i];
            a2 = jet.a[startIndex + i];
            kx = kx_p[startIndex + i];
            ky = ky_p[startIndex + i];
            phi1 = p[startIndex + i];
            phi2 = jet.p[startIndex + i];
            deltaPhi = phi1 - phi2;

            // eq. (8) assumes that -pi <= phi - phi' - dk <= +pi,
            // for EVERY j. So, if you have estimated a larger d0
            // using smaller k, when you want to refine the d0 using
            // BOTH smaller k and larger k, you have to adjust (phi - phi')
            // corresponding to LARGER k by 2n*pi, otherwise for some of the j
            // (corresponding to larger k), the premise above does not meet,
            // and the estimated d will not be precise.
            float ddotk, adjust;
            ddotk = dx0*kx + dy0*ky;
            adjust = (wrapAngle(deltaPhi - ddotk + PI) - PI) - (deltaPhi - ddotk);
            deltaPhi += adjust;
            //if(abs(adjust) > 0.01) {
                //std::cout << startIndex + i << "\t" << adjust << "\n";
            //}

            Phi_x += a1*a2*kx*(deltaPhi);
            Phi_y += a1*a2*ky*(deltaPhi);

            Gamma_xy = Gamma_yx += a1*a2*kx*ky;
            Gamma_xx += a1*a2*kx*kx;
            Gamma_yy += a1*a2*ky*ky;
        }

        float denominator = Gamma_xx*Gamma_yy - Gamma_xy*Gamma_yx;
        float dx = (Gamma_yy*Phi_x - Gamma_yx*Phi_y) / denominator;
        float dy = (Gamma_xx*Phi_y - Gamma_xy*Phi_x) / denominator;

        return std::make_tuple(dx, dy);
    }

    
};


 

//// -------------- Normal Version ----------------
//// Calculates jets at different points of one image
//// Only support one-channel matrices.
//template <int N>
//class CalcJet {
//private:
    //bool m_init = false;    
    //Kernels<N> m_kernels;
    //Convolution m_conv;
    //int m_width = 0;
    //int m_height = 0;

    //// DO NOT modify kx and ky in a jet!
    //// The ks used to generate Garbor kernels.
    //// Different jets generated by the same set of Garbor
    //// kernels will have the same ks, so I use heap to
    //// reduce memory usage.
    //std::shared_ptr<float[]> m_kx;
    //std::shared_ptr<float[]> m_ky;

//public:
    //// Will copy the data of src into an internal Mat in this class, and
    //// this internel Mat will be used in other functions of this class.
    //// So you do not need to call Mat::clone() when passing src.
    //// Will copy the data of kernels into an internal structure in this class.
    //void init(
        //const cv::Mat &src,
        //const Kernels<N> &kernels,
        //int maxKernelRows,
        //int maxKernelCols
    //)
    //{
        //assert(!kernels.re[0].empty());
        //assert(src.type() == kernels.re[0].type());

        //m_kernels = kernels;
        //m_width = src.cols;
        //m_height = src.rows;
        //m_conv.init(src, maxKernelRows, maxKernelCols);

        //m_kx.reset(new float[N]);
        //m_ky.reset(new float[N]);
        //memcpy(m_kx.get(), kernels.kx, sizeof(float)*N);
        //memcpy(m_ky.get(), kernels.ky, sizeof(float)*N);

        //m_init = true;
    //}

    //Jet<N> calcJet(int x, int y) const
    //{
        //assert(m_init);
        //assert(x >= 0 && x < m_width);
        //assert(y >= 0 && y < m_height);

        //Jet<N> ret;
        //ret.x = x;
        //ret.y = y;
        //ret.kx = m_kx;
        //ret.ky = m_ky;
        
        //for(int i = 0; i < N; i++){
            //float re, im;
            //re = m_conv.calcConv(m_kernels.re[i], x, y);
            //im = m_conv.calcConv(m_kernels.im[i], x, y);
            
            //std::tie(ret.a[i], ret.p[i]) = complex2mag(re, im);
        //}

        //return ret;
    //}

    //std::tuple<int/*width*/, int/*height*/>
    //getSrcSize() const
    //{
        //return std::make_tuple(m_width, m_height);
    //}

    //CalcJet() noexcept {}

    //// Will copy the data of src into an internal Mat in this class, and
    //// this internel Mat will be used in other functions of this class.
    //// So you do not need to call Mat::clone() when passing src.
    //// Will copy the data of kernels into an internal structure in this class.
    //CalcJet(
        //const cv::Mat &src,
        //const Kernels<N> &kernels,
        //int maxKernelRows,
        //int maxKernelCols
    //) noexcept
    //{
        //init(
            //src, 
            //kernels, 
            //maxKernelRows, 
            //maxKernelCols
        //);
    //}

//};


// -------------- Cache Version ----------------
// Calculates jets at different points of one image
// Only support one-channel matrices.
template <int N>
class CalcJet {
public:
    // When constructed by deserialization:
    //     If not set, the kx and ky of jets will use the value saved in file.
    //     If set, the kx and ky of jets will use these variables directly.
    // When constructed by init():
    //     These variables will be the same as Kernels::kx and Kernels::ky.
    std::shared_ptr<float[]> m_kx;
    std::shared_ptr<float[]> m_ky;

private:
    bool m_init = false;    
    int m_width = 0;
    int m_height = 0;

    std::unique_ptr<float[]> m_cachea;
    std::unique_ptr<float[]> m_cachep;
    int cacheIndex(int x, int y) const {
        return N*(y*m_width + x);
    }

    friend class boost::serialization::access;

    template<class Archive>
    void load(Archive & ar, const unsigned int version)
    {
        ar & m_init;
        ar & m_width;
        ar & m_height;
        
        if(m_init){
            std::shared_ptr<float[]> tmpkx(new float[N]);
            std::shared_ptr<float[]> tmpky(new float[N]);
            float *kx = tmpkx.get();
            float *ky = tmpky.get();
            for(int i=0; i<N; i++) {
                ar & kx[i];
            }
            for(int i=0; i<N; i++) {
                ar & ky[i];
            }
            if(!m_kx || !m_ky) {
                m_kx = tmpkx;
                m_ky = tmpky;
            }

            int nCache = N*m_width*m_height;
            m_cachea.reset(new float[nCache]);
            m_cachep.reset(new float[nCache]);
            float *cachea = m_cachea.get();
            float *cachep = m_cachep.get();
            for(int i=0; i<nCache; i++){
                ar & cachea[i];
            }
            for(int i=0; i<nCache; i++){
                ar & cachep[i];
            }
        }
    }

    template<class Archive>
    void save(Archive & ar, const unsigned int version) const
    {
        ar & m_init;
        ar & m_width;
        ar & m_height;
        
        if(m_init){
            float *kx = m_kx.get();
            float *ky = m_ky.get();
            for(int i=0; i<N; i++) {
                ar & kx[i];
            }
            for(int i=0; i<N; i++) {
                ar & ky[i];
            }

            int nCache = N*m_width*m_height;
            float *cachea = m_cachea.get();
            float *cachep = m_cachep.get();
            for(int i=0; i<nCache; i++){
                ar & cachea[i];
            }
            for(int i=0; i<nCache; i++){
                ar & cachep[i];
            }
        }
    }

    BOOST_SERIALIZATION_SPLIT_MEMBER()

public:
    // Will copy the data of src into an internal Mat in this class, and
    // this internel Mat will be used in other functions of this class.
    // So you do not need to call Mat::clone() when passing src.
    // Will copy the data of kernels into an internal structure in this class.
    void init(
        const cv::Mat &src,
        const Kernels<N> &kernels,
        int maxKernelRows,
        int maxKernelCols
    )
    {
        assert(!kernels.re[0].empty());
        assert(src.type() == kernels.re[0].type());

        m_width = src.cols;
        m_height = src.rows;
        m_cachea.reset(new float[N*m_width*m_height]);
        m_cachep.reset(new float[N*m_width*m_height]);

        Convolution conv;
        conv.init(src, maxKernelRows, maxKernelCols);

        #pragma omp parallel for collapse(2) schedule(static)
        for(int ix=0; ix<m_width; ix++){
            for(int iy=0; iy<m_height; iy++){
                float *cachea = m_cachea.get() + cacheIndex(ix, iy);
                float *cachep = m_cachep.get() + cacheIndex(ix, iy);

                for(int i = 0; i < N; i++){
                    float re, im;
                    re = conv.calcConv(kernels.re[i], ix, iy);
                    im = conv.calcConv(kernels.im[i], ix, iy);
                    
                    std::tie(cachea[i], cachep[i]) = complex2mag(re, im);
                }
            }
        }

        m_kx = kernels.kx;
        m_ky = kernels.ky;

        m_init = true;
    }

    Jet<N> calcJet(int x, int y) const
    {
        assert(m_init);
        assert(x >= 0 && x < m_width);
        assert(y >= 0 && y < m_height);

        Jet<N> ret;
        ret.x = x;
        ret.y = y;
        ret.kx = m_kx;
        ret.ky = m_ky;

        float *cachea = m_cachea.get() + cacheIndex(x, y);
        float *cachep = m_cachep.get() + cacheIndex(x, y);

        memcpy(ret.a, cachea, 40*sizeof(float));
        memcpy(ret.p, cachep, 40*sizeof(float));

        return ret;
    }

    std::tuple<int/*width*/, int/*height*/>
    getSrcSize() const
    {
        return std::make_tuple(m_width, m_height);
    }

    CalcJet() noexcept {}

    // Will copy the data of src into an internal Mat in this class, and
    // this internel Mat will be used in other functions of this class.
    // So you do not need to call Mat::clone() when passing src.
    // Will copy the data of kernels into an internal structure in this class.
    CalcJet(
        const cv::Mat &src,
        const Kernels<N> &kernels,
        int maxKernelRows,
        int maxKernelCols
    ) noexcept
    {
        init(
            src, 
            kernels, 
            maxKernelRows, 
            maxKernelCols
        );
    }

};
